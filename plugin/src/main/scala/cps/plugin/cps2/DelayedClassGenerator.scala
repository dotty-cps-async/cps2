package cps.plugin.cps2

import dotty.tools.dotc.*
import dotty.tools.dotc.ast.tpd
import dotty.tools.dotc.ast.tpd.*
import dotty.tools.dotc.ast.TreeTypeMap
import core.*
import core.Names.*
import core.Contexts.*
import core.Decorators.*
import core.Symbols.*
import core.Types.*
import core.Flags.*
import core.Scopes.{newScope, MutableScope}
import core.StdNames.nme
import dotty.tools.dotc.config.Feature

/**
 * Generates delayed class variants for function-storing classes.
 *
 * When a class stores function arguments (e.g., `LazyB[A, B](source: List[A], f: A => B)`),
 * we generate a "delayed" class for async support:
 *
 *   class LazyB_cps[F_SHIFT[_], A, B](m: CpsTryMonad[F_SHIFT], source: List[A], f: A => F_SHIFT[B]):
 *     def _finishChain: F_SHIFT[LazyB[A, B]] = cpsPhase1Scaffold(m, LazyB(source, x => scaffoldAwait(f(x))))
 *     def toList_async: F_SHIFT[List[B]] = cpsPhase1Scaffold(m, source.map(x => scaffoldAwait(f(x))))
 *     def reverse_async[C](g: B => F_SHIFT[C]): LazyA_cps[...] = ...
 *
 * The delayed class:
 * - Has an additional F_SHIFT[_] type parameter for the effect monad
 * - Has constructor params: monad m + shifted versions of original constructor params
 * - Contains `_finishChain` method to complete the async chain
 * - Contains `method_async` for each method from the original class
 * - Is placed in the same scope as the original class
 */
object DelayedClassGenerator {

  /** Registry of auto-generated delayed class symbols, keyed by original class symbol */
  private val autoGeneratedDelayedClasses = scala.collection.mutable.Map[Symbol, Symbol]()

  /** Clear the registry (call at start of each compilation unit) */
  def clearAutoGeneratedRegistry(): Unit = {
    autoGeneratedDelayedClasses.clear()
  }

  /**
   * Find an auto-generated delayed class for the given original class.
   */
  def findAutoGeneratedDelayedClass(originalClass: Symbol)(using Context): Option[Symbol] = {
    autoGeneratedDelayedClasses.get(originalClass)
  }

  /**
   * Get the delayed class name for a given original class name.
   */
  def getDelayedClassName(originalName: Name): TypeName = {
    (originalName.toString + "_cps").toTypeName
  }

  /**
   * Check if a class symbol stores functions (has function-typed constructor params).
   * Such classes need a delayed variant for call-chain async support.
   */
  def isFunctionStoringClassSymbol(classSym: ClassSymbol)(using Context): Boolean = {
    val primaryCtor = classSym.primaryConstructor

    if (!primaryCtor.exists) return false

    // Check if any constructor parameter is a function type
    primaryCtor.paramSymss.flatten.exists { param =>
      CpsTypeHelper.isAnyFunction(param.info)
    }
  }

  /**
   * Check if a class definition stores functions (has function-typed constructor params).
   * Such classes need a delayed variant for call-chain async support.
   */
  def isFunctionStoringClass(tree: TypeDef)(using Context): Boolean = {
    if (!tree.isClassDef) return false
    isFunctionStoringClassSymbol(tree.symbol.asClass)
  }

  /**
   * Generate a delayed class for a function-storing class defined in a TypeDef.
   * Used for nested classes.
   */
  def generateDelayedClassSignature(tree: TypeDef)(using Context): Option[TypeDef] = {
    if (!tree.isClassDef) return None

    val originalClass = tree.symbol.asClass
    // Get template from the TypeDef's rhs
    tree.rhs match {
      case template: Template =>
        generateDelayedClass(originalClass, template, tree.srcPos.span)
      case _ =>
        None
    }
  }

  /**
   * Generate a delayed class for a top-level function-storing class.
   * Called when the template's owner is a function-storing class.
   */
  def generateDelayedClassSignatureForSymbol(originalClass: ClassSymbol, template: tpd.Template)(using Context): Option[TypeDef] = {
    generateDelayedClass(originalClass, template, template.srcPos.span)
  }

  /**
   * Main implementation: generate a delayed class with constructor params and scaffold bodies.
   */
  private def generateDelayedClass(
    originalClass: ClassSymbol,
    template: Template,
    coord: util.Spans.Span
  )(using Context): Option[TypeDef] = {
    val delayedClassName = (originalClass.name.toString + "_cps").toTypeName
    val owner = originalClass.owner

    // Check if original class already has @delayedVariant annotation (user-provided)
    val delayedVariantAnnotClass = Symbols.getClassIfDefined("cps.annotation.delayedVariant")
    if (delayedVariantAnnotClass.exists && originalClass.hasAnnotation(delayedVariantAnnotClass.asClass)) {
      println(s"CPS2 Plugin: ${originalClass.name} already has @delayedVariant annotation (user-provided)")
      return None
    }

    // Check if delayed class already exists in the same scope (by symbol lookup)
    // This replaces the registry-based check with direct symbol table lookup
    val existingDelayed = owner.info.member(delayedClassName).symbol
    if (existingDelayed.exists && existingDelayed.isClass) {
      // Already exists - register it and skip generation
      autoGeneratedDelayedClasses(originalClass) = existingDelayed
      return None
    }

    // Check if we already processed this (fallback for same compilation unit)
    if (autoGeneratedDelayedClasses.contains(originalClass)) {
      return None
    }

    val isTopLevel = owner.is(Package)
    val suffix = if (isTopLevel) " (top-level)" else ""
    println(s"CPS2 Plugin: Generating delayed class ${delayedClassName} for${suffix} ${originalClass.name}")

    val origTypeParams = originalClass.typeParams

    // Create scope that will hold all members
    val decls = newScope

    // =========================================================================
    // Type parameters: F_SHIFT[_], then original type params
    // =========================================================================
    val fBounds = TypeBounds(defn.NothingType, HKTypeLambda.any(1))
    val typeParamFlags = TypeParam | Deferred | Private | Local

    // Create temporary type param symbols (will be re-parented to class later)
    val fTypeParamSym = Symbols.newSymbol(
      owner, "F_SHIFT".toTypeName,
      typeParamFlags | Covariant,
      fBounds,
      coord = coord
    )

    val copiedTypeParamSyms = origTypeParams.map { tp =>
      Symbols.newSymbol(
        owner, tp.name,
        typeParamFlags | (tp.flags & VarianceFlags),
        tp.info,  // Copy bounds
        coord = coord
      )
    }

    val allTypeParamSyms = fTypeParamSym :: copiedTypeParamSyms

    // =========================================================================
    // Build parents and create class
    // =========================================================================
    val parents = List(defn.ObjectType.typeSymbol.typeRef)

    // Get original constructor VALUE params only (exclude type params)
    val origCtor = originalClass.primaryConstructor
    val origCtorParamss = origCtor.paramSymss.map(_.filterNot(_.isType)).filterNot(_.isEmpty)

    // Get the constructor's TYPE params - these may be different from class type params!
    val origCtorTypeParams = origCtor.paramSymss.headOption.getOrElse(Nil).filter(_.isType)

    // Create class symbol with complete info
    val cls = Symbols.newCompleteClassSymbol(
      owner = owner,
      name = delayedClassName,
      flags = Synthetic,
      parents = parents,
      decls = decls,
      selfInfo = NoType,
      privateWithin = NoSymbol,
      coord = coord
    )

    // Re-parent type param symbols to the class and enter into decls
    val clsTypeParamSyms = allTypeParamSyms.map { tp =>
      val newTp = Symbols.newSymbol(
        cls, tp.name.asTypeName,
        tp.flags,
        tp.info,
        coord = tp.coord
      )
      decls.enter(newTp)
      newTp
    }

    val fShiftRef = clsTypeParamSyms.head.typeRef
    val otherTypeRefs = clsTypeParamSyms.tail.map(_.typeRef)
    // Type substitution: original type params -> new type params
    // We need to substitute BOTH:
    // 1. Constructor type params - used in constructor param types
    // 2. Class type params - used in method bodies
    // These may be different symbols in Scala 3.
    val origClassTypeParams = originalClass.typeParams
    val ctorTypeSubst: Map[Symbol, Type] = origCtorTypeParams.zip(otherTypeRefs).toMap
    val classTypeSubst: Map[Symbol, Type] = origClassTypeParams.zip(otherTypeRefs).toMap
    val typeSubst: Map[Symbol, Type] = ctorTypeSubst ++ classTypeSubst

    // =========================================================================
    // Constructor: m: CpsTryMonad[F_SHIFT], then shifted original params
    // =========================================================================
    val monadType = Symbols.requiredClassRef("cps.CpsTryMonad").appliedTo(fShiftRef)

    val shiftedCtorParamTypes: List[List[Type]] = {
      val monadParams = List(monadType)
      val shiftedOrigParams = origCtorParamss.map { paramList =>
        paramList.map { param =>
          val origType = param.info
          val substType = substTypeParams(origType, typeSubst)
          if (CpsTypeHelper.isAnyFunction(origType)) {
            CpsTransformHelper.cpsTransformedType(substType, fShiftRef)
          } else {
            substType
          }
        }
      }
      monadParams :: shiftedOrigParams
    }

    val shiftedCtorParamNames: List[List[TermName]] = {
      val monadNames = List("m".toTermName)
      val origNames = origCtorParamss.map(_.map(_.name.toTermName))
      monadNames :: origNames
    }

    // For a polymorphic class, the constructor needs a PolyType wrapping the MethodType.
    // This allows `new LazyA_cps[F, A, B](m, source, f)` to work with type parameters.
    //
    // The constructor type should be:
    //   [F_SHIFT, A, B] => (m: CpsTryMonad[F_SHIFT], source: List[A], f: A => F_SHIFT[B]): LazyA_cps[F_SHIFT, A, B]
    val ctorType = if (clsTypeParamSyms.nonEmpty) {
      // Create PolyType for type parameters
      val typeParamNames = clsTypeParamSyms.map(_.name.asTypeName)
      val typeParamBounds = clsTypeParamSyms.map(_.info.asInstanceOf[TypeBounds])

      PolyType(typeParamNames)(
        pt => typeParamBounds,
        pt => {
          // Substitute class type param refs with constructor's polytype param refs
          val polyRefs = clsTypeParamSyms.indices.map(i => pt.newParamRef(i)).toList
          val ctorTypeSubst = clsTypeParamSyms.zip(polyRefs).map { case (sym, ref) => sym.typeRef -> ref }.toMap

          def substCtorTypes(tp: Type): Type = {
            var result = tp
            for ((from, to) <- ctorTypeSubst) {
              result = result.subst(List(from.typeSymbol), List(to))
            }
            result
          }

          val substParamTypes = shiftedCtorParamTypes.flatten.map(substCtorTypes)
          val substResultType = substCtorTypes(cls.typeRef.appliedTo(clsTypeParamSyms.map(_.typeRef)))

          MethodType(shiftedCtorParamNames.flatten, substParamTypes, substResultType)
        }
      )
    } else {
      // Non-polymorphic class - use simple MethodType
      MethodType(shiftedCtorParamNames.flatten, shiftedCtorParamTypes.flatten, cls.typeRef)
    }

    val ctor = Symbols.newSymbol(cls, nme.CONSTRUCTOR, Method | Synthetic, ctorType, coord = coord)
    decls.enter(ctor)

    // Create field symbols for constructor params (make them accessible in methods)
    // These are the param accessors that allow `this.source`, `this.f`, etc.
    //
    // IMPORTANT: We must use the SAME type param symbols (clsTypeParamSyms) that we used
    // to build shiftedCtorParamTypes. The ctor param symbols may have different type refs
    // after going through newConstructor. So we recreate the types from scratch here.
    val allCtorNames = shiftedCtorParamNames.flatten
    val allCtorTypes = shiftedCtorParamTypes.flatten
    val fieldSyms = allCtorNames.zip(allCtorTypes).map { case (name, tp) =>
      val fieldSym = Symbols.newSymbol(
        cls,
        name,
        Private | Local | ParamAccessor,
        tp,  // Use the types we built directly, not from ctor.paramSymss
        coord = coord
      )
      decls.enter(fieldSym)
      fieldSym
    }

    // Identify which ctor params are function-typed (in the original class)
    val origFunctionParamNames = origCtorParamss.flatten.filter { param =>
      CpsTypeHelper.isAnyFunction(param.info)
    }.map(_.name).toSet

    // Build params info for body generation - use field symbols which are accessible
    val paramsInfo = DelayedClassParamsInfo(
      monadParamSym = fieldSyms.head,  // m is first field
      origCtorParamSyms = fieldSyms.tail,  // rest are original params (shifted)
      origCtorFunctionParams = fieldSyms.tail.filter(p => origFunctionParamNames.contains(p.name)).toSet,
      fShiftRef = fShiftRef,
      typeSubst = typeSubst
    )

    // =========================================================================
    // _finishChain method: def _finishChain: F_SHIFT[Original[...]^{this.f, ...}]
    // The return type must include captures of the function fields
    // =========================================================================
    val origApplied = if (otherTypeRefs.isEmpty) {
      originalClass.typeRef
    } else {
      originalClass.typeRef.appliedTo(otherTypeRefs)
    }

    // The return type does not include captures - we use a wider type.
    // The body will be cast to match.
    val origWithCaptures = origApplied
    val finishChainResultType = fShiftRef.appliedTo(origWithCaptures)

    val finishChainSym = Symbols.newSymbol(
      cls, "_finishChain".toTermName,
      Method,
      finishChainResultType,
      coord = coord
    )
    decls.enter(finishChainSym)

    // =========================================================================
    // Async methods: for each method in original class (not ctor, not accessor)
    // =========================================================================
    val origMethods = template.body.collect {
      case dd: DefDef if !dd.symbol.isConstructor && !dd.symbol.is(Accessor) => dd
    }

    val asyncMethodSyms = origMethods.flatMap { dd =>
      generateAsyncMethodSignature(dd, cls, fShiftRef, typeSubst, coord)
    }

    asyncMethodSyms.foreach(decls.enter)

    // Enter class into owner's scope
    cls.entered

    // Debug: print class info to understand type params
    println(s"DEBUG DelayedClassGenerator: cls=${cls.fullName}, cls.typeParams=${cls.typeParams.map(_.name)}")
    println(s"DEBUG DelayedClassGenerator: cls.info=${cls.info}")
    println(s"DEBUG DelayedClassGenerator: cls.typeRef=${cls.typeRef.show}")

    // =========================================================================
    // Create trees: constructor, _finishChain, async methods
    // =========================================================================

    // Constructor DefDef
    val ctorDef = DefDef(ctor.asTerm, paramss => EmptyTree)

    // Type param trees
    val typeParamDefs = clsTypeParamSyms.map(tp => TypeDef(tp.asType))

    // _finishChain DefDef with scaffold body
    val finishChainDef = DefDef(finishChainSym.asTerm, paramss => {
      given Context = summon[Context].withOwner(finishChainSym)
      generateFinishChainBody(cls, originalClass, template, paramsInfo, coord)
    })

    // Async method DefDefs with scaffold bodies
    val asyncMethodDefs = origMethods.zip(asyncMethodSyms).map { case (origDd, asyncSym) =>
      DefDef(asyncSym.asTerm, asyncParamss => {
        given Context = summon[Context].withOwner(asyncSym)
        println(s"DEBUG: generating async body for ${asyncSym.name}, origMethod=${origDd.name}")
        val body = generateAsyncMethodBody(origDd, asyncSym, asyncParamss, cls, originalClass, paramsInfo, coord)
        println(s"DEBUG: async body generated for ${asyncSym.name}: ${body.show.take(100)}")
        body
      })
    }

    // Build class tree
    println(s"DEBUG: About to build ClassDefWithParents for ${cls.name}")
    println(s"DEBUG: finishChainSym.info = ${finishChainSym.info.show}")
    asyncMethodSyms.foreach { sym =>
      println(s"DEBUG: asyncMethodSym ${sym.name}.info = ${sym.info.show}")
      println(s"DEBUG: asyncMethodSym ${sym.name}.info.getClass = ${sym.info.getClass.getSimpleName}")
    }
    origMethods.foreach { dd =>
      println(s"DEBUG: origMethod ${dd.name}.tpe = ${dd.tpe.show}")
      println(s"DEBUG: origMethod ${dd.name}.tpe.resultType = ${ShiftedMethodGenerator.getMethodReturnType(dd).show}")
    }
    val typeDef = ClassDefWithParents(
      cls,
      ctorDef,
      parents.map(TypeTree(_)),
      typeParamDefs ++ List(finishChainDef) ++ asyncMethodDefs
    )

    autoGeneratedDelayedClasses(originalClass) = cls
    val typeParamStr = clsTypeParamSyms.map(_.name.toString).mkString("[", ", ", "]")
    println(s"CPS2 Plugin: Successfully generated ${delayedClassName}${typeParamStr}${suffix}")
    println(s"=== Generated TypeDef for ${delayedClassName} ===")
    println(typeDef.show)
    println(s"=== End TypeDef for ${delayedClassName} ===")
    Some(typeDef)
  }

  /**
   * Substitute type parameters in a type.
   */
  private def substTypeParams(tp: Type, subst: Map[Symbol, Type])(using Context): Type = {
    if (subst.isEmpty) tp
    else {
      val (oldSyms, newTypes) = subst.toList.unzip
      tp.subst(oldSyms, newTypes)
    }
  }

  /**
   * Generate signature for an async version of a method.
   * Returns the method symbol.
   */
  private def generateAsyncMethodSignature(
    origMethod: DefDef,
    delayedClass: ClassSymbol,
    fShiftRef: Type,
    typeSubst: Map[Symbol, Type],
    coord: util.Spans.Span
  )(using Context): Option[Symbol] = {
    val origSym = origMethod.symbol
    val asyncName = (origSym.name.toString + "_async").toTermName

    // Get original method type and transform it
    val origType = origSym.info
    val asyncType = transformMethodTypeForAsync(origType, fShiftRef, typeSubst)

    val asyncSym = Symbols.newSymbol(
      delayedClass, asyncName,
      Method | Synthetic,
      asyncType,
      coord = coord
    )

    Some(asyncSym)
  }

  /**
   * Transform a method type for async: shift function params, wrap return in F_SHIFT.
   */
  private def transformMethodTypeForAsync(tp: Type, fShiftRef: Type, typeSubst: Map[Symbol, Type])(using Context): Type = {
    tp match {
      case pt: PolyType =>
        PolyType(pt.paramNames)(
          _ => pt.paramInfos,
          npt => {
            val newRefs = pt.paramNames.indices.map(i => npt.newParamRef(i)).toList
            // Just substitute and recurse - PolyType param refs handled by substParams at end
            transformMethodTypeForAsync(pt.resultType, fShiftRef, typeSubst).substParams(pt, newRefs)
          }
        )
      case mt: MethodType =>
        val shiftedParamTypes = mt.paramInfos.map { paramType =>
          val substType = substTypeParams(paramType, typeSubst)
          if (CpsTypeHelper.isImpureFunction(substType)) {
            CpsTransformHelper.cpsTransformedType(substType, fShiftRef)
          } else {
            substType
          }
        }
        MethodType(mt.paramNames)(_ => shiftedParamTypes, _ => {
          transformMethodTypeForAsync(mt.resultType, fShiftRef, typeSubst)
        })
      case et: ExprType =>
        // By-name type (=> T) - unwrap and recurse
        transformMethodTypeForAsync(et.resultType, fShiftRef, typeSubst)
      case other =>
        // Terminal result type - check if it's a call-chain type or wrap in F_SHIFT
        val substType = substTypeParams(other, typeSubst)
        if (ShiftedMethodGenerator.isCallChainIntermediateType(substType)) {
          ShiftedMethodGenerator.getCallChainReturnType(substType, fShiftRef)
        } else {
          fShiftRef.appliedTo(substType)
        }
    }
  }

  /**
   * Information about delayed class constructor params for body generation.
   */
  case class DelayedClassParamsInfo(
    monadParamSym: Symbol,           // m: CpsTryMonad[F_SHIFT]
    origCtorParamSyms: List[Symbol], // original ctor params (shifted types)
    origCtorFunctionParams: Set[Symbol], // which of origCtorParamSyms are function-typed
    fShiftRef: Type,
    typeSubst: Map[Symbol, Type]
  )

  /**
   * Generate _finishChain body: cpsPhase1Scaffold(m, Original(source, x => scaffoldAwait(f(x))))
   *
   * Creates the original class instance by:
   * 1. Referencing non-function constructor params directly (this.source)
   * 2. Wrapping function params with await: this.f -> (x => scaffoldAwait(this.f(x)))
   */
  private def generateFinishChainBody(
    delayedClass: ClassSymbol,
    originalClass: ClassSymbol,
    template: Template,
    paramsInfo: DelayedClassParamsInfo,
    coord: util.Spans.Span
  )(using Context): Tree = {
    val fShiftRef = paramsInfo.fShiftRef

    // Get original class type params applied with delayed class type params
    // Use original CLASS type params (not typeSubst.values which may have duplicates
    // from both class and constructor type params)
    val origTypeParams = originalClass.typeParams
    val otherTypeRefs = origTypeParams.map(tp => paramsInfo.typeSubst.getOrElse(tp, tp.typeRef))
    val origApplied = if (otherTypeRefs.isEmpty) {
      originalClass.typeRef
    } else {
      originalClass.typeRef.appliedTo(otherTypeRefs)
    }

    // Build constructor arguments: wrap function params with await lambda
    // Access delayed class fields via this.fieldName
    val ctorArgs = paramsInfo.origCtorParamSyms.map { paramSym =>
      // Look up the field symbol in delayed class by name
      val fieldSym = delayedClass.info.member(paramSym.name).symbol
      val paramRef = if (fieldSym.exists) {
        This(delayedClass).select(fieldSym)
      } else {
        // Fallback: try to reference via accessor
        ref(paramSym)
      }

      if (paramsInfo.origCtorFunctionParams.contains(paramSym)) {
        // Function param: wrap with await lambda
        wrapFunctionParamWithAwait(paramRef, paramSym.info, fShiftRef)
      } else {
        // Non-function param: use directly
        paramRef
      }
    }

    // Build: new Original[A, B](args...)
    val rawClassType = originalClass.typeRef
    val newTree = New(TypeTree(rawClassType)).select(nme.CONSTRUCTOR)

    // Apply delayed class's type refs as type args
    val withTypeArgs = if (otherTypeRefs.nonEmpty) {
      val typeArgs = otherTypeRefs.map(TypeTree(_))
      TypeApply(newTree, typeArgs)
    } else {
      newTree
    }

    // Build the New(...) expression
    val newOriginal = Apply(withTypeArgs, ctorArgs)

    // The body type is the base type without captures.
    // We'll cast the body expression to this type to handle capture checking.
    val bodyType = origApplied

    // CPS return type: F_SHIFT[bodyType]
    val cpsReturnType = fShiftRef.appliedTo(bodyType)

    // Monad ref: this.m
    val monadRef = This(delayedClass).select(paramsInfo.monadParamSym)

    // Cast the body to the expected type to strip capture annotations.
    // The body captures this.f, but we want to treat it as LazyA[A, B] without captures.
    val bodyCast = newOriginal.asInstance(bodyType)

    // Wrap in cpsPhase1Scaffold[F, T, R](m, body)
    generateScaffoldCall(fShiftRef, bodyType, cpsReturnType, monadRef, bodyCast)
  }

  /**
   * Generate async method body: scaffold-wrapped original body with await insertions.
   *
   * For original method:
   *   def toList: List[B] = source.map(f)
   *
   * Generate:
   *   def toList_async: F_SHIFT[List[B]] =
   *     cpsPhase1Scaffold[F_SHIFT, List[B], F_SHIFT[List[B]]](m,
   *       this.source.map((x: A) => scaffoldAwait(this.f(x)))
   *     )
   */
  private def generateAsyncMethodBody(
    origMethod: DefDef,
    asyncSym: Symbol,
    asyncParamss: List[List[Tree]],
    delayedClass: ClassSymbol,
    originalClass: ClassSymbol,
    paramsInfo: DelayedClassParamsInfo,
    coord: util.Spans.Span
  )(using Context): Tree = {
    val fShiftRef = paramsInfo.fShiftRef
    val origBody = origMethod.rhs

    // If original method has no body (abstract), return ???
    if (origBody.isEmpty) {
      return ref(defn.Predef_undefined)
    }

    // Use ShiftedMethodGenerator's infrastructure for body transformation
    // This handles all the complexity of PolyType params, method params, etc.

    // Get function params that need await wrapping
    val functionParams = origMethod.paramss.flatten.collect {
      case vd: ValDef if CpsTypeHelper.isImpureFunction(vd.symbol.info) => vd
    }

    // Build shifted params info from asyncParamss
    val baseShiftedParamsInfo = ShiftedMethodGenerator.buildShiftedParamsInfoForDelayed(
      origMethod,
      asyncParamss,
      fShiftRef,
      This(delayedClass).select(paramsInfo.monadParamSym)
    )

    // Add class-level type param substitution (original class type params -> delayed class type params)
    // This is needed because method bodies reference the ORIGINAL CLASS's type params (A, B),
    // but when we transform field accesses to use delayed class fields, those fields have
    // the DELAYED CLASS's type params (A', B').
    val origClassTypeParams = originalClass.typeParams
    val delayedClassTypeParams = delayedClass.typeParams.drop(1) // skip F_SHIFT
    val classTypeSubst: Map[Symbol, Type] = origClassTypeParams.zip(delayedClassTypeParams.map(_.typeRef)).toMap

    // Merge with any method-specific type substitutions
    val combinedTypeSymbolSubst: Map[Symbol, Type] = classTypeSubst ++ baseShiftedParamsInfo.typeSymbolSubst

    val shiftedParamsInfo = baseShiftedParamsInfo.copy(typeSymbolSubst = combinedTypeSymbolSubst)

    println(s"DEBUG generateAsyncMethodBody: step 1 - shiftedParamsInfo built")

    // Get original return type and substitute using ShiftedMethodGenerator's logic
    val origReturnType = ShiftedMethodGenerator.getMethodReturnType(origMethod)
    println(s"DEBUG generateAsyncMethodBody: step 2 - origReturnType = ${origReturnType.show}")
    val originalReturnType = ShiftedMethodGenerator.substituteAllParams(origReturnType, shiftedParamsInfo)
    println(s"DEBUG generateAsyncMethodBody: step 3 - originalReturnType = ${originalReturnType.show}")

    // Check if this is a call-chain method (returns another function-storing class)
    val isCallChainMethod = ShiftedMethodGenerator.isCallChainIntermediateType(originalReturnType)
    println(s"DEBUG generateAsyncMethodBody: step 4 - isCallChainMethod = $isCallChainMethod")

    // Transform the body with class field handling
    println(s"DEBUG generateAsyncMethodBody: step 5 - about to transform body")
    val transformedBody = ShiftedMethodGenerator.transformBodyForDelayed(
      origBody,
      delayedClass,
      originalClass,
      paramsInfo.origCtorFunctionParams,
      functionParams,
      shiftedParamsInfo,
      fShiftRef,
      origMethod.symbol,
      asyncSym
    )
    println(s"DEBUG generateAsyncMethodBody: step 6 - body transformed: ${transformedBody.show.take(80)}")

    // Compute CPS return type
    val cpsReturnType = if (isCallChainMethod) {
      // For call-chain methods, return type is the delayed class
      ShiftedMethodGenerator.getCallChainReturnType(originalReturnType, fShiftRef)
    } else {
      // For non-call-chain methods, return type is F[T]
      CpsTransformHelper.cpsTransformedType(originalReturnType, fShiftRef)
    }
    println(s"DEBUG generateAsyncMethodBody: step 7 - cpsReturnType = ${cpsReturnType.show}")

    // Wrap in cpsPhase1Scaffold[F, T, R](m, body)
    // - T = originalReturnType (e.g., LazyB[A, C] or List[B])
    // - R = cpsReturnType (e.g., LazyB_cps[F, A, C] or F[List[B]])
    val result = ShiftedMethodGenerator.generateScaffoldCall(
      fShiftRef,
      originalReturnType,
      cpsReturnType,
      shiftedParamsInfo.monadRef,
      transformedBody
    )
    println(s"DEBUG generateAsyncMethodBody: step 8 - scaffold call generated: ${result.show.take(80)}")
    result
  }

  /**
   * Transform method body: substitute params, wrap function calls with await.
   */
  private def transformMethodBody(
    body: Tree,
    delayedClass: ClassSymbol,
    originalClass: ClassSymbol,
    paramsInfo: DelayedClassParamsInfo,
    paramSubst: Map[Symbol, Tree],
    asyncFunctionParams: Set[Symbol]
  )(using Context): Tree = {
    val fShiftRef = paramsInfo.fShiftRef

    val mapper = new TreeMap {
      override def transform(tree: Tree)(using Context): Tree = tree match {
        // this.field where field is a function -> wrap with await
        case sel @ Select(ths: This, name) if ths.symbol == originalClass =>
          // Reference to original class field -> reference delayed class field
          val delayedFieldSym = delayedClass.info.member(name).symbol
          if (delayedFieldSym.exists) {
            val delayedRef = This(delayedClass).select(delayedFieldSym)
            if (paramsInfo.origCtorFunctionParams.exists(_.name == name)) {
              // Function field: wrap with await lambda
              wrapFunctionParamWithAwait(delayedRef, delayedFieldSym.info, fShiftRef)
            } else {
              delayedRef
            }
          } else {
            super.transform(tree)
          }

        // Param reference -> substitute with new param (possibly wrapped)
        case id: Ident if paramSubst.contains(id.symbol) =>
          val newRef = paramSubst(id.symbol)
          if (asyncFunctionParams.contains(id.symbol)) {
            // Async function param used as value: wrap with await lambda
            wrapFunctionParamWithAwait(newRef, id.tpe, fShiftRef)
          } else {
            newRef
          }

        // Function application where function is async param -> insert await
        case app @ Apply(fun, args) =>
          val asyncNames = asyncFunctionParams.map(_.name) ++ paramsInfo.origCtorFunctionParams.map(_.name)
          extractAsyncFunctionFromCall(fun, asyncNames) match {
            case Some(_) =>
              // Transform the application, then wrap result with await
              val transformedApp = super.transform(app)
              insertScaffoldAwait(transformedApp, fShiftRef)
            case None =>
              super.transform(tree)
          }

        case _ =>
          super.transform(tree)
      }
    }

    mapper.transform(body)
  }

  /**
   * Extract async function symbol from a call if the callee is an async function param.
   */
  private def extractAsyncFunctionFromCall(fun: Tree, asyncFunNames: Set[Name])(using Context): Option[Symbol] = {
    fun match {
      case id: Ident if asyncFunNames.contains(id.symbol.name) => Some(id.symbol)
      case Select(_, name) if asyncFunNames.contains(name) => Some(fun.symbol)
      case Select(qual, nme.apply) => extractAsyncFunctionFromCall(qual, asyncFunNames)
      case Apply(inner, _) => extractAsyncFunctionFromCall(inner, asyncFunNames)
      case TypeApply(inner, _) => extractAsyncFunctionFromCall(inner, asyncFunNames)
      case _ => None
    }
  }

  /**
   * Wrap a function reference with await lambda: f -> (x => scaffoldAwait(f(x)))
   */
  private def wrapFunctionParamWithAwait(funcRef: Tree, funcType: Type, fShiftRef: Type)(using Context): Tree = {
    // Extract function param and result types
    val funcTypeWidened = funcType.widen.dealias
    funcTypeWidened match {
      case AppliedType(tycon, targs) if defn.isFunctionType(funcTypeWidened) || defn.isContextFunctionType(funcTypeWidened) =>
        val paramTypes = targs.dropRight(1)
        val asyncResultType = targs.last  // This is F_SHIFT[T]

        // Extract T from F_SHIFT[T]
        val innerResultType = asyncResultType match {
          case AppliedType(_, args) if args.nonEmpty => args.head
          case _ => asyncResultType
        }

        // Build lambda: (x0, x1, ...) => scaffoldAwait(f(x0, x1, ...))
        val paramNames = paramTypes.indices.map(i => s"x$i".toTermName).toList
        val mt = MethodType(paramNames)(_ => paramTypes, _ => innerResultType)
        val methSym = Symbols.newAnonFun(summon[Context].owner, mt)

        Closure(methSym, { tss =>
          val paramRefs = tss.head
          val funcApp = funcRef.select(nme.apply).appliedToArgs(paramRefs)
          insertScaffoldAwait(funcApp, fShiftRef)
        })

      case _ =>
        // Not a function type, return as-is
        funcRef
    }
  }

  /**
   * Insert scaffoldAwait[F, T](expr) around an expression.
   */
  private def insertScaffoldAwait(expr: Tree, fShiftRef: Type)(using Context): Tree = {
    val exprType = expr.tpe.widen
    val innerType = exprType match {
      case AppliedType(_, args) if args.nonEmpty => args.head
      case _ => exprType
    }

    val awaitMethod = ref(Symbols.requiredMethod("cps.plugin.scaffoldAwait"))
    Apply(
      TypeApply(awaitMethod, List(TypeTree(fShiftRef), TypeTree(innerType))),
      List(expr)
    )
  }

  /**
   * Generate cpsPhase1Scaffold[F, T, R](m, body) call.
   */
  private def generateScaffoldCall(
    fShiftType: Type,
    originalReturnType: Type,
    cpsReturnType: Type,
    monadRef: Tree,
    body: Tree
  )(using Context): Tree = {
    val scaffoldMethod = ref(Symbols.requiredMethod("cps.plugin.cpsPhase1Scaffold"))
    Apply(
      TypeApply(
        scaffoldMethod,
        List(
          TypeTree(fShiftType),
          TypeTree(originalReturnType),
          TypeTree(cpsReturnType)
        )
      ),
      List(monadRef, body)
    )
  }

  /**
   * Get the return type of a method type.
   * Unwraps PolyType, MethodType, and ExprType wrappers.
   */
  private def getMethodReturnType(tp: Type)(using Context): Type = tp match {
    case pt: PolyType => getMethodReturnType(pt.resultType)
    case mt: MethodType => getMethodReturnType(mt.resultType)
    case et: ExprType => et.resultType  // Unwrap by-name type (=> T)
    case other => other
  }

}

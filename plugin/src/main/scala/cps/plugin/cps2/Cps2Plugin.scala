package cps.plugin.cps2

import dotty.tools.dotc.ast.Trees.*
import dotty.tools.dotc.ast.tpd
import dotty.tools.dotc.core.Contexts.Context
import dotty.tools.dotc.core.Types.*
import dotty.tools.dotc.core.Symbols.*
import dotty.tools.dotc.core.Names.*
import dotty.tools.dotc.core.Flags.*
import dotty.tools.dotc.core.Decorators.*
import dotty.tools.dotc.core.Annotations.Annotation
import dotty.tools.dotc.config.Feature
import dotty.tools.dotc.plugins.{PluginPhase, StandardPlugin}
import dotty.tools.dotc.transform.{Pickler, PostTyper, Inlining, PostInlining}
import dotty.tools.dotc.report
import scala.collection.mutable.ListBuffer

class Cps2Plugin extends StandardPlugin:
  val name: String = "cps2-plugin"
  val description: String = "Minimal CPS2 compiler plugin"

  override def init(options: List[String]): List[PluginPhase] =
    // Two phases: one before Pickler to create signatures, one after to fill bodies
    List(new Cps2SignaturePhase, new Cps2ImplementationPhase)

/** Phase 1: Runs before Pickler - Creates method signatures that will be in TASTY */
class Cps2SignaturePhase extends PluginPhase:
  val phaseName = "cps2-signatures"
  override val runsAfter = Set(PostTyper.name)
  override val runsBefore = Set(Pickler.name)

  // Required for enteredAfter to work - we add new class/method symbols
  override def changesMembers = true

  private var warnedAboutCC = false

  // Accumulate top-level delayed classes to be added at package level
  private val pendingTopLevelDelayedClasses = scala.collection.mutable.ListBuffer[tpd.TypeDef]()

  private def checkCCWarning(tree: tpd.Tree)(using Context): Unit =
    if (!Feature.ccEnabled && !warnedAboutCC) {
      warnedAboutCC = true
      report.warning(
        "CPS2 plugin works best with capture checking enabled. " +
        "Add 'import language.experimental.captureChecking' to your source files.",
        tree.srcPos
      )
    }

  override def prepareForUnit(tree: tpd.Tree)(using Context): Context =
    // Clear pending top-level classes and registry at the start of each unit.
    // The registry helps track within-unit generation; symbol lookup handles cross-unit.
    pendingTopLevelDelayedClasses.clear()
    DelayedClassGenerator.clearAutoGeneratedRegistry()
    summon[Context]

  override def transformUnit(tree: tpd.Tree)(using Context): tpd.Tree =
    // Add any pending top-level delayed classes to the compilation unit
    // This runs AFTER all template transforms, ensuring classes are added at the right level
    tree match {
      case pd: tpd.PackageDef if pendingTopLevelDelayedClasses.nonEmpty =>
        val newStats = pd.stats ++ pendingTopLevelDelayedClasses.toList
        println(s"CPS2 Plugin (Phase 1): Adding ${pendingTopLevelDelayedClasses.size} top-level delayed classes to compilation unit")
        pendingTopLevelDelayedClasses.clear()
        tpd.cpy.PackageDef(pd)(pd.pid, newStats)
      case _ =>
        tree
    }

  override def transformTemplate(tree: tpd.Template)(using Context): tpd.Tree =
    checkCCWarning(tree)

    // TWO-PHASE TEMPLATE PROCESSING:
    //
    // Phase A: Generate delayed class signatures for function-storing classes
    //          This makes them available for lookup when generating shifted methods
    //
    // Phase B: Generate shifted methods for HOFs
    //          The delayed types are now findable
    //
    // NOTE: Registry is cleared in prepareForUnit, not here, to avoid clearing
    // between nested templates within the same compilation unit.

    // Phase A: Scan for function-storing classes and generate delayed variants
    // Check both:
    // 1. Nested classes in template body (e.g., class inside object)
    // 2. The template's owner itself (for top-level classes)

    val nestedDelayedClasses = tree.body.collect {
      case td: tpd.TypeDef if DelayedClassGenerator.isFunctionStoringClass(td) =>
        DelayedClassGenerator.generateDelayedClassSignature(td)
    }.flatten

    // For top-level classes: check if template's owner is a function-storing class
    // For TOP-LEVEL classes, we DON'T add the delayed class to this template because
    // it would make it nested. Instead, we only generate for truly nested classes
    // where the template owner is not a top-level class.
    //
    // Top-level delayed classes need to be generated at package level, which is
    // handled separately in prepareForUnit. For now, we rely on forward references.
    val ownerDelayedClass = summon[Context].owner match {
      case cls: ClassSymbol if !cls.owner.is(Package) && DelayedClassGenerator.isFunctionStoringClassSymbol(cls) =>
        // Only for nested classes (owner is NOT a package)
        DelayedClassGenerator.generateDelayedClassSignatureForSymbol(cls, tree)
      case cls: ClassSymbol if cls.owner.is(Package) && DelayedClassGenerator.isFunctionStoringClassSymbol(cls) =>
        // For top-level classes, generate but DON'T add to this template
        // Accumulate for package-level addition
        DelayedClassGenerator.generateDelayedClassSignatureForSymbol(cls, tree).foreach { typeDef =>
          pendingTopLevelDelayedClasses += typeDef
        }
        None // Don't add to this template
      case _ => None
    }

    val delayedClasses = nestedDelayedClasses ++ ownerDelayedClass.toList

    if (delayedClasses.nonEmpty) {
      println(s"CPS2 Plugin (Phase 1): Generated ${delayedClasses.size} delayed class signatures")
    }

    // Phase B: Generate shifted methods for DefDefs with impure function params
    // Now delayed types from Phase A are available for lookup
    val shiftedMethods = tree.body.collect {
      case dd: tpd.DefDef =>
        ShiftedMethodGenerator.generateShiftedMethod(dd) match
          case Some(shiftedMethod) =>
            println(s"CPS2 Plugin (Phase 1): Generated ${shiftedMethod.name} for ${dd.name}")
            Some(shiftedMethod)
          case None =>
            None
    }.flatten

    // Phase C: Detect direct functions and mark with @directFunction annotation
    // Direct functions are those whose result type captures CpsMonadContext
    val directFunctionCount = if (Feature.ccEnabled) {
      markDirectFunctions(tree.body)
    } else 0

    if (directFunctionCount > 0) {
      println(s"CPS2 Plugin (Phase 1): Marked $directFunctionCount direct functions")
    }

    // Phase D: Add generated classes and methods to template
    if (shiftedMethods.nonEmpty || delayedClasses.nonEmpty) {
      val methodCount = shiftedMethods.size
      val classCount = delayedClasses.size
      println(s"CPS2 Plugin (Phase 1): Adding $methodCount shifted methods and $classCount delayed classes to template")

      val newBody = tree.body ++ delayedClasses ++ shiftedMethods
      tpd.cpy.Template(tree)(body = newBody)
    } else {
      tree
    }

  /**
   * Detect direct functions and add @directFunction annotation.
   * Returns count of marked functions.
   */
  private def markDirectFunctions(body: List[tpd.Tree])(using Context): Int = {
    val directFunctionAnnotClass = getClassIfDefined("cps.annotation.directFunction")
    if (!directFunctionAnnotClass.exists) {
      return 0
    }

    var count = 0
    body.foreach {
      case dd: tpd.DefDef if CaptureAnalysis.isDirectFunction(dd) =>
        val sym = dd.symbol
        // Only add annotation if not already present
        if (!sym.hasAnnotation(directFunctionAnnotClass)) {
          val annot = Annotation(directFunctionAnnotClass.asClass, dd.span)
          sym.addAnnotation(annot)
          println(s"CPS2 Plugin (Phase 1): Marked ${sym.name} as @directFunction")
          count += 1
        }
      case _ =>
    }
    count
  }

/** Phase 2: Runs after Pickler - Fills in the actual implementation */
class Cps2ImplementationPhase extends PluginPhase:
  val phaseName = "cps2-implementation"
  override val runsAfter = Set(Inlining.name)
  override val runsBefore = Set(PostInlining.name)

  override def transformDefDef(tree: tpd.DefDef)(using Context): tpd.Tree =
    // Check if this is a shifted method stub that needs implementation
    if (isShiftedStub(tree)) {
      println(s"CPS2 Plugin (Phase 2): Found stub ${tree.name} - TODO: fill implementation")
      fillShiftedImplementation(tree)
    } else {
      tree
    }

  override def transformApply(tree: tpd.Apply)(using Context): tpd.Tree =
    // Transform call sites to use shifted versions when appropriate
    // This will be implemented in Phase 2 (Capability Detection)
    tree

  private def isShiftedStub(tree: tpd.DefDef)(using ctx: Context): Boolean =
    // Check if this is a method ending with "_async" and has ??? body
    tree.name.toString.endsWith("_async") &&
    tree.symbol.is(Synthetic) &&
    tree.rhs.symbol == ctx.definitions.Predef_undefined

  private def fillShiftedImplementation(tree: tpd.DefDef)(using ctx: Context): tpd.DefDef =
    // Fill in actual shifted implementation
    // For now, keep as ??? - will implement body transformation later
    // Future: Call original method and wrap with monad operations
    tree
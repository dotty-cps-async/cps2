package cps.plugin.cps2

import dotty.tools.dotc.*
import core.*
import core.Contexts.*
import core.Decorators.*
import core.Symbols.*
import core.Types.*

/**
 * Helper for CPS type transformations.
 * Minimal port from dotty-cps-async.
 */
object CpsTransformHelper {

  /**
   * Transform a type for CPS: wrap result types in F[_].
   *
   * - Simple types T become F[T]
   * - Function types (A => B) become (A => F[B])
   * - Method types have their result types transformed
   * - Poly types have their result types transformed
   * - Function-storing classes become delayed: WithFilter[A] -> WithFilter_cps[F, A]
   *
   * @param t the type to transform
   * @param fType the monad type constructor F[_]
   * @return the CPS-transformed type
   */
  def cpsTransformedType(t: Type, fType: Type)(using Context): Type = {
    t match
      case AppliedType(funCn, params) =>
        if (defn.isFunctionType(t) || defn.isContextFunctionType(t)) then
          // Function type: transform last type arg (result) to F[result]
          val nParams = adoptResultTypeParam(params, fType)
          AppliedType(funCn, nParams)
        else
          // Check if this is a function-storing class that needs delayed variant
          findDelayedClass(funCn.typeSymbol) match
            case Some(delayedSym) =>
              // WithFilter[A] -> WithFilter_cps[F, A]
              AppliedType(delayedSym.typeRef, fType :: params)
            case None =>
              // Other applied type: wrap whole thing in F
              fType.appliedTo(t.widen)
      case mt: MethodType =>
        if (mt.isContextualMethod)
          mt.derivedLambdaType(mt.paramNames, mt.paramInfos, cpsTransformedType(mt.resType, fType))
        else if (mt.isImplicitMethod)
          ImplicitMethodType(mt.paramNames)(_ => mt.paramInfos, _ => cpsTransformedType(mt.resType, fType))
        else
          MethodType(mt.paramNames)(_ => mt.paramInfos, _ => cpsTransformedType(mt.resType, fType))
      case pt: PolyType =>
        PolyType(pt.paramNames)(_ => pt.paramInfos, _ => cpsTransformedType(pt.resType, fType))
      case tr: TypeRef =>
        // Check if this is a function-storing class
        findDelayedClass(tr.typeSymbol) match
          case Some(delayedSym) =>
            // T -> T_cps[F]
            AppliedType(delayedSym.typeRef, List(fType))
          case None =>
            // Simple type: wrap in F[_]
            fType.appliedTo(t.widen)
      case _ =>
        // Simple type: wrap in F[_]
        fType.appliedTo(t.widen)
  }

  /**
   * Find the delayed class for a given type symbol.
   * Checks:
   * 1. Auto-generated delayed classes registry
   * 2. If symbol is a function-storing class, look for existing _cps class
   */
  private def findDelayedClass(sym: Symbol)(using Context): Option[Symbol] = {
    if (!sym.isClass) return None
    val classSym = sym.asClass

    // Check auto-generated registry first
    DelayedClassGenerator.findAutoGeneratedDelayedClass(classSym) match
      case Some(delayed) => Some(delayed)
      case None =>
        // Check if it's a function-storing class with existing _cps sibling
        if (DelayedClassGenerator.isFunctionStoringClassSymbol(classSym)) then
          val delayedName = DelayedClassGenerator.getDelayedClassName(classSym.name)
          val delayedSym = classSym.owner.info.decl(delayedName).symbol
          if (delayedSym.exists) Some(delayedSym) else None
        else
          None
  }

  /**
   * Transform the last type parameter (result type) for CPS.
   * [T1, ..., Tn, R] becomes [T1, ..., Tn, F[R]]
   */
  private def adoptResultTypeParam(targs: List[Type], fType: Type)(using Context): List[Type] = {
    targs match
      case Nil => Nil
      case last :: Nil => cpsTransformedType(last, fType) :: Nil
      case head :: tail => head :: adoptResultTypeParam(tail, fType)
  }

}
